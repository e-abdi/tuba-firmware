
#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/i2c.h>
#include <zephyr/drivers/uart.h>
#include <zephyr/logging/log.h>
#include "hw_bmp180.h"

LOG_MODULE_REGISTER(bmp180_impl, LOG_LEVEL_INF);

static const struct device *const i2c0_dev = DEVICE_DT_GET_OR_NULL(DT_NODELABEL(i2c0));
static const struct device *const uart_cons = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));

#define BMP180_ADDR     0x77
#define REG_CALIB_START 0xAA
#define REG_CTRL_MEAS   0xF4
#define REG_DATA_MSB    0xF6
#define CMD_TEMP        0x2E
#define CMD_PRES_OSS3   0xF4 /* oss=3 */

struct calib {
    int16_t AC1; int16_t AC2; int16_t AC3; uint16_t AC4; uint16_t AC5; uint16_t AC6;
    int16_t B1; int16_t B2; int16_t MB; int16_t MC; int16_t MD;
};
static struct calib cal;

static int read_regs(uint8_t addr, uint8_t *buf, size_t len) {
    int rc = i2c_write_read(i2c0_dev, BMP180_ADDR, &addr, 1, buf, len);
    return rc;
}
static int write_reg(uint8_t reg, uint8_t val) {
    uint8_t tx[2] = {reg, val};
    return i2c_write(i2c0_dev, tx, 2, BMP180_ADDR);
}

static int read_calib(void) {
    uint8_t b[22];
    int rc = read_regs(REG_CALIB_START, b, sizeof(b));
    if (rc) return rc;
    cal.AC1 = (int16_t)((b[0]<<8)|b[1]);
    cal.AC2 = (int16_t)((b[2]<<8)|b[3]);
    cal.AC3 = (int16_t)((b[4]<<8)|b[5]);
    cal.AC4 = (uint16_t)((b[6]<<8)|b[7]);
    cal.AC5 = (uint16_t)((b[8]<<8)|b[9]);
    cal.AC6 = (uint16_t)((b[10]<<8)|b[11]);
    cal.B1  = (int16_t)((b[12]<<8)|b[13]);
    cal.B2  = (int16_t)((b[14]<<8)|b[15]);
    cal.MB  = (int16_t)((b[16]<<8)|b[17]);
    cal.MC  = (int16_t)((b[18]<<8)|b[19]);
    cal.MD  = (int16_t)((b[20]<<8)|b[21]);
    return 0;
}

int bmp180_init(void) {
    if (i2c0_dev == NULL || !device_is_ready(i2c0_dev)) return -ENODEV;
    return read_calib();
}

static int read_raw_temp(int32_t *UT) {
    int rc = write_reg(REG_CTRL_MEAS, CMD_TEMP);
    if (rc) return rc;
    k_msleep(5);
    uint8_t b[2];
    rc = read_regs(REG_DATA_MSB, b, 2);
    if (rc) return rc;
    *UT = (int32_t)((b[0]<<8)|b[1]);
    return 0;
}
static int read_raw_press(int32_t *UP) {
    int rc = write_reg(REG_CTRL_MEAS, CMD_PRES_OSS3);
    if (rc) return rc;
    k_msleep(26);
    uint8_t b[3];
    rc = read_regs(REG_DATA_MSB, b, 3);
    if (rc) return rc;
    *UP = (((int32_t)b[0] << 16) | ((int32_t)b[1] << 8) | b[2]) >> (8-3);
    return 0;
}

/* Return temperature in 0.1C and pressure in Pa */
static void compensate(int32_t UT, int32_t UP, int32_t *T_cdec, int32_t *P_pa) {
    int32_t X1 = ((UT - (int32_t)cal.AC6) * (int32_t)cal.AC5) >> 15;
    int32_t X2 = ((int32_t)cal.MC << 11) / (X1 + cal.MD);
    int32_t B5 = X1 + X2;
    *T_cdec = (B5 + 8) >> 4;

    int32_t B6 = B5 - 4000;
    X1 = ((int32_t)cal.B2 * ((B6 * B6) >> 12)) >> 11;
    X2 = ((int32_t)cal.AC2 * B6) >> 11;
    int32_t X3 = X1 + X2;
    int32_t B3 = ((((int32_t)cal.AC1 * 4 + X3) << 3) + 2) >> 2;

    X1 = ((int32_t)cal.AC3 * B6) >> 13;
    X2 = ((int32_t)cal.B1 * ((B6 * B6) >> 12)) >> 16;
    X3 = ((X1 + X2) + 2) >> 2;
    uint32_t B4 = ((uint32_t)cal.AC4 * (uint32_t)(X3 + 32768)) >> 15;
    uint32_t B7 = ((uint32_t)UP - B3) * 50000U;

    int32_t p = (B7 < 0x80000000U) ? (B7 / B4) << 1 : (B7 / B4) * 2;
    X1 = (p >> 8) * (p >> 8);
    X1 = (X1 * 3038) >> 16;
    X2 = (-7357 * p) >> 16;
    p = p + ((X1 + X2 + 3791) >> 4);
    *P_pa = p;
}

void bmp180_stream_interactive(void) {
    int32_t UT=0, UP=0, T=0, P=0;
    if (!device_is_ready(uart_cons)) {
        while (1) { k_sleep(K_SECONDS(1)); }
    }
    LOG_INF("BMP180 stream: press 'q' + Enter to quit");
    while (1) {
        if (read_raw_temp(&UT)==0 && read_raw_press(&UP)==0) {
            compensate(UT, UP, &T, &P);
            LOG_INF("INT Pressure: %.3f kPa  Temp: %.2f C", P/1000.0, T/10.0);
        } else {
            LOG_ERR("BMP180 read error");
        }
        /* Exit on 'q' */
        unsigned char ch;
        if (uart_poll_in(uart_cons, &ch) == 0) {
            if (ch == 'q' || ch == 'Q') break;
        }
        k_sleep(K_SECONDS(1));
    }
}
